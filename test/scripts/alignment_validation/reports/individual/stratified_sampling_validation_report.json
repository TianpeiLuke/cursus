{
  "script_name": "stratified_sampling",
  "level1": {
    "passed": true,
    "issues": [
      {
        "severity": "WARNING",
        "category": "environment_variables",
        "message": "Optional environment variable accessed without default: VARIANCE_COLUMN",
        "details": {
          "variable": "VARIANCE_COLUMN",
          "line": 392,
          "script": "stratified_sampling"
        },
        "recommendation": "Provide default value when accessing optional variable VARIANCE_COLUMN"
      },
      {
        "severity": "INFO",
        "category": "arguments",
        "message": "Script defines config-driven argument provided by builder: --job-type (accessed as args.job_type)",
        "details": {
          "cli_argument": "job-type",
          "python_attribute": "job_type",
          "script": "stratified_sampling",
          "source": "builder"
        },
        "recommendation": "Argument --job-type is provided by builder - no action needed"
      },
      {
        "severity": "INFO",
        "category": "testability_compliance",
        "message": "Main function follows testability pattern with all required parameters",
        "details": {
          "script": "stratified_sampling",
          "testability_parameters": [
            "output_paths",
            "input_paths",
            "environ_vars",
            "job_args"
          ]
        },
        "recommendation": "No action needed - script follows testability best practices"
      },
      {
        "severity": "WARNING",
        "category": "testability_env_access",
        "message": "Helper functions use direct environment access - consider parameter passing",
        "details": {
          "script": "stratified_sampling",
          "helper_accesses": [
            {
              "function": null,
              "variable": "STRATA_COLUMN",
              "line_number": 385
            },
            {
              "function": null,
              "variable": "SAMPLING_STRATEGY",
              "line_number": 389
            },
            {
              "function": null,
              "variable": "TARGET_SAMPLE_SIZE",
              "line_number": 390
            },
            {
              "function": null,
              "variable": "MIN_SAMPLES_PER_STRATUM",
              "line_number": 391
            },
            {
              "function": null,
              "variable": "VARIANCE_COLUMN",
              "line_number": 392
            },
            {
              "function": null,
              "variable": "RANDOM_STATE",
              "line_number": 393
            }
          ]
        },
        "recommendation": "Pass environment variables as parameters to helper functions instead of direct access"
      },
      {
        "severity": "WARNING",
        "category": "testability_entry_point",
        "message": "Main function expects environ_vars parameter but no environment collection found in entry point",
        "details": {
          "script": "stratified_sampling"
        },
        "recommendation": "Add environment variable collection in __main__ block to pass to main function"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for job_args",
        "details": {
          "script": "stratified_sampling",
          "parameter": "job_args",
          "current_pattern": "job_args.job_type",
          "line_number": 267
        },
        "recommendation": "Use job_args['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for environ_vars",
        "details": {
          "script": "stratified_sampling",
          "parameter": "environ_vars",
          "current_pattern": "environ_vars.get",
          "line_number": 268
        },
        "recommendation": "Use environ_vars['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for environ_vars",
        "details": {
          "script": "stratified_sampling",
          "parameter": "environ_vars",
          "current_pattern": "environ_vars.get",
          "line_number": 269
        },
        "recommendation": "Use environ_vars['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for environ_vars",
        "details": {
          "script": "stratified_sampling",
          "parameter": "environ_vars",
          "current_pattern": "environ_vars.get",
          "line_number": 270
        },
        "recommendation": "Use environ_vars['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for environ_vars",
        "details": {
          "script": "stratified_sampling",
          "parameter": "environ_vars",
          "current_pattern": "environ_vars.get",
          "line_number": 271
        },
        "recommendation": "Use environ_vars['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for environ_vars",
        "details": {
          "script": "stratified_sampling",
          "parameter": "environ_vars",
          "current_pattern": "environ_vars.get",
          "line_number": 272
        },
        "recommendation": "Use environ_vars['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for environ_vars",
        "details": {
          "script": "stratified_sampling",
          "parameter": "environ_vars",
          "current_pattern": "environ_vars.get",
          "line_number": 273
        },
        "recommendation": "Use environ_vars['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for input_paths",
        "details": {
          "script": "stratified_sampling",
          "parameter": "input_paths",
          "current_pattern": "input_paths.get",
          "line_number": 276
        },
        "recommendation": "Use input_paths['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for output_paths",
        "details": {
          "script": "stratified_sampling",
          "parameter": "output_paths",
          "current_pattern": "output_paths.get",
          "line_number": 277
        },
        "recommendation": "Use output_paths['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_parameter_access",
        "message": "Consider using dictionary-style access for job_args",
        "details": {
          "script": "stratified_sampling",
          "parameter": "job_args",
          "current_pattern": "args.job_type",
          "line_number": 409
        },
        "recommendation": "Use job_args['key'] for accessing nested values"
      },
      {
        "severity": "INFO",
        "category": "testability_container_support",
        "message": "No container detection found - consider adding hybrid mode support",
        "details": {
          "script": "stratified_sampling"
        },
        "recommendation": "Add container detection to support both local and container execution"
      },
      {
        "severity": "WARNING",
        "category": "testability_helper_functions",
        "message": "Helper function 'None' accesses environment directly",
        "details": {
          "script": "stratified_sampling",
          "function": null,
          "env_variables": [
            "STRATA_COLUMN",
            "SAMPLING_STRATEGY",
            "TARGET_SAMPLE_SIZE",
            "MIN_SAMPLES_PER_STRATUM",
            "VARIANCE_COLUMN",
            "RANDOM_STATE"
          ],
          "line_numbers": [
            385,
            389,
            390,
            391,
            392,
            393
          ]
        },
        "recommendation": "Refactor 'None' to accept environment variables as parameters"
      },
      {
        "severity": "INFO",
        "category": "framework_detected",
        "message": "Processing script uses sklearn framework",
        "details": {
          "script": "stratified_sampling",
          "step_type": "Processing",
          "framework": "sklearn"
        },
        "recommendation": "Ensure sklearn dependencies are properly specified"
      }
    ],
    "script_analysis": {
      "script_path": "/Users/tianpeixie/github_workspace/cursus/src/cursus/steps/scripts/stratified_sampling.py",
      "path_references": [
        "path='Extract stratum information from DataFrame.' line_number=71 context='    \\n    def _get_strata_info(self, df: pd.DataFrame, strata_column: str, variance_column: Optional[str] = None) -> Dict:\\n>>>         \"\"\"Extract stratum information from DataFrame.\"\"\"\\n        strata_info = {}\\n        ' is_hardcoded=True construction_method=None",
        "path='Perform the actual sampling based on allocation.' line_number=196 context='    \\n    def _perform_sampling(self, df: pd.DataFrame, strata_column: str, allocation: Dict[Any, int]) -> pd.DataFrame:\\n>>>         \"\"\"Perform the actual sampling based on allocation.\"\"\"\\n        sampled_dfs = []\\n        ' is_hardcoded=True construction_method=None",
        "path='Read processed data from tabular_preprocessing output structure.' line_number=218 context='\\ndef _read_processed_data(input_dir: str, split_name: str) -> pd.DataFrame:\\n>>>     \"\"\"Read processed data from tabular_preprocessing output structure.\"\"\"\\n    input_path = Path(input_dir)\\n    split_dir = input_path / split_name' is_hardcoded=True construction_method=None",
        "path='_processed_data.csv' line_number=223 context='    \\n    # Look for the processed data file\\n>>>     processed_file = split_dir / f\"{split_name}_processed_data.csv\"\\n    \\n    if not processed_file.exists():' is_hardcoded=True construction_method=None",
        "path='Save sampled data maintaining the same folder structure as tabular_preprocessing.' line_number=232 context='\\ndef _save_sampled_data(df: pd.DataFrame, output_dir: str, split_name: str, logger: Callable[[str], None]):\\n>>>     \"\"\"Save sampled data maintaining the same folder structure as tabular_preprocessing.\"\"\"\\n    output_path = Path(output_dir)\\n    split_dir = output_path / split_name' is_hardcoded=True construction_method=None",
        "path='_processed_data.csv' line_number=238 context='    \\n    # Save with same naming convention\\n>>>     output_file = split_dir / f\"{split_name}_processed_data.csv\"\\n    df.to_csv(output_file, index=False)\\n    logger(f\"[INFO] Saved {output_file} (shape={df.shape})\")' is_hardcoded=True construction_method=None",
        "path='/opt/ml/processing/input/data' line_number=276 context='    \\n    # Extract paths\\n>>>     input_data_dir = input_paths.get(\"data_input\", \"/opt/ml/processing/input/data\")\\n    output_dir = output_paths.get(\"data_output\", \"/opt/ml/processing/output\")\\n    ' is_hardcoded=True construction_method=None",
        "path='/opt/ml/processing/output' line_number=277 context='    # Extract paths\\n    input_data_dir = input_paths.get(\"data_input\", \"/opt/ml/processing/input/data\")\\n>>>     output_dir = output_paths.get(\"data_output\", \"/opt/ml/processing/output\")\\n    \\n    # Use print function if no logger is provided' is_hardcoded=True construction_method=None",
        "path='STRATA_COLUMN environment variable must be set.' line_number=284 context='    # Validate required parameters\\n    if not strata_column:\\n>>>         raise RuntimeError(\"STRATA_COLUMN environment variable must be set.\")\\n    \\n    if sampling_strategy not in [\\'balanced\\', \\'proportional_min\\', \\'optimal\\']:' is_hardcoded=True construction_method=None",
        "path=' split...' line_number=316 context='    for split_name in splits_to_process:\\n        try:\\n>>>             log(f\"[INFO] Processing {split_name} split...\")\\n            \\n            # Read the processed data from tabular_preprocessing output' is_hardcoded=True construction_method=None",
        "path=\"' not found. Using default variance for optimal allocation.\" line_number=328 context='            # Check if variance column exists (for optimal strategy)\\n            if sampling_strategy == \\'optimal\\' and variance_column and variance_column not in df.columns:\\n>>>                 log(f\"[WARNING] Variance column \\'{variance_column}\\' not found. Using default variance for optimal allocation.\")\\n                variance_column = None\\n            ' is_hardcoded=True construction_method=None",
        "path='[INFO] Stratified sampling complete.' line_number=368 context='            log(f\"[WARNING] Could not copy test split: {str(e)}\")\\n    \\n>>>     log(\"[INFO] Stratified sampling complete.\")\\n    return sampled_splits\\n' is_hardcoded=True construction_method=None",
        "path='STRATA_COLUMN environment variable must be set.' line_number=387 context='        STRATA_COLUMN = os.environ.get(\"STRATA_COLUMN\")\\n        if not STRATA_COLUMN:\\n>>>             raise RuntimeError(\"STRATA_COLUMN environment variable must be set.\")\\n        \\n        SAMPLING_STRATEGY = os.environ.get(\"SAMPLING_STRATEGY\", \"balanced\")' is_hardcoded=True construction_method=None",
        "path='/opt/ml/processing/input/data' line_number=396 context='\\n        # Define standard SageMaker paths - use contract-declared paths directly\\n>>>         INPUT_DATA_DIR = \"/opt/ml/processing/input/data\"\\n        OUTPUT_DIR = \"/opt/ml/processing/output\"\\n' is_hardcoded=True construction_method=None",
        "path='/opt/ml/processing/output' line_number=397 context='        # Define standard SageMaker paths - use contract-declared paths directly\\n        INPUT_DATA_DIR = \"/opt/ml/processing/input/data\"\\n>>>         OUTPUT_DIR = \"/opt/ml/processing/output\"\\n\\n        # Set up logging' is_hardcoded=True construction_method=None"
      ],
      "env_var_accesses": [
        "variable_name='STRATA_COLUMN' line_number=385 context='\\n        # Read configuration from environment variables\\n>>>         STRATA_COLUMN = os.environ.get(\"STRATA_COLUMN\")\\n        if not STRATA_COLUMN:\\n            raise RuntimeError(\"STRATA_COLUMN environment variable must be set.\")' access_method='os.environ.get' has_default=False default_value=None",
        "variable_name='SAMPLING_STRATEGY' line_number=389 context='            raise RuntimeError(\"STRATA_COLUMN environment variable must be set.\")\\n        \\n>>>         SAMPLING_STRATEGY = os.environ.get(\"SAMPLING_STRATEGY\", \"balanced\")\\n        TARGET_SAMPLE_SIZE = int(os.environ.get(\"TARGET_SAMPLE_SIZE\", 1000))\\n        MIN_SAMPLES_PER_STRATUM = int(os.environ.get(\"MIN_SAMPLES_PER_STRATUM\", 10))' access_method='os.environ.get' has_default=True default_value='balanced'",
        "variable_name='TARGET_SAMPLE_SIZE' line_number=390 context='        \\n        SAMPLING_STRATEGY = os.environ.get(\"SAMPLING_STRATEGY\", \"balanced\")\\n>>>         TARGET_SAMPLE_SIZE = int(os.environ.get(\"TARGET_SAMPLE_SIZE\", 1000))\\n        MIN_SAMPLES_PER_STRATUM = int(os.environ.get(\"MIN_SAMPLES_PER_STRATUM\", 10))\\n        VARIANCE_COLUMN = os.environ.get(\"VARIANCE_COLUMN\")  # Optional' access_method='os.environ.get' has_default=True default_value=None",
        "variable_name='MIN_SAMPLES_PER_STRATUM' line_number=391 context='        SAMPLING_STRATEGY = os.environ.get(\"SAMPLING_STRATEGY\", \"balanced\")\\n        TARGET_SAMPLE_SIZE = int(os.environ.get(\"TARGET_SAMPLE_SIZE\", 1000))\\n>>>         MIN_SAMPLES_PER_STRATUM = int(os.environ.get(\"MIN_SAMPLES_PER_STRATUM\", 10))\\n        VARIANCE_COLUMN = os.environ.get(\"VARIANCE_COLUMN\")  # Optional\\n        RANDOM_STATE = int(os.environ.get(\"RANDOM_STATE\", 42))' access_method='os.environ.get' has_default=True default_value=None",
        "variable_name='VARIANCE_COLUMN' line_number=392 context='        TARGET_SAMPLE_SIZE = int(os.environ.get(\"TARGET_SAMPLE_SIZE\", 1000))\\n        MIN_SAMPLES_PER_STRATUM = int(os.environ.get(\"MIN_SAMPLES_PER_STRATUM\", 10))\\n>>>         VARIANCE_COLUMN = os.environ.get(\"VARIANCE_COLUMN\")  # Optional\\n        RANDOM_STATE = int(os.environ.get(\"RANDOM_STATE\", 42))\\n' access_method='os.environ.get' has_default=False default_value=None",
        "variable_name='RANDOM_STATE' line_number=393 context='        MIN_SAMPLES_PER_STRATUM = int(os.environ.get(\"MIN_SAMPLES_PER_STRATUM\", 10))\\n        VARIANCE_COLUMN = os.environ.get(\"VARIANCE_COLUMN\")  # Optional\\n>>>         RANDOM_STATE = int(os.environ.get(\"RANDOM_STATE\", 42))\\n\\n        # Define standard SageMaker paths - use contract-declared paths directly' access_method='os.environ.get' has_default=True default_value=None"
      ],
      "imports": [
        "module_name='os' import_alias=None line_number=2 is_from_import=False imported_items=[]",
        "module_name='argparse' import_alias=None line_number=3 is_from_import=False imported_items=[]",
        "module_name='logging' import_alias=None line_number=4 is_from_import=False imported_items=[]",
        "module_name='sys' import_alias=None line_number=5 is_from_import=False imported_items=[]",
        "module_name='traceback' import_alias=None line_number=6 is_from_import=False imported_items=[]",
        "module_name='pathlib' import_alias=None line_number=7 is_from_import=True imported_items=['Path']",
        "module_name='typing' import_alias=None line_number=8 is_from_import=True imported_items=['Dict', 'Optional', 'Callable', 'Any', 'Tuple']",
        "module_name='pandas' import_alias='pd' line_number=9 is_from_import=False imported_items=[]",
        "module_name='numpy' import_alias='np' line_number=10 is_from_import=False imported_items=[]",
        "module_name='sklearn.model_selection' import_alias=None line_number=11 is_from_import=True imported_items=['train_test_split']"
      ],
      "argument_definitions": [
        "argument_name='job_type' line_number=375 is_required=True has_default=False default_value=None argument_type='str' choices=['training', 'validation', 'testing', 'calibration']"
      ],
      "file_operations": [],
      "step_type": "Processing",
      "framework": "sklearn",
      "step_type_patterns": {}
    },
    "contract": {
      "entry_point": "stratified_sampling.py",
      "inputs": {
        "processed_data": {
          "path": "/opt/ml/processing/input/data"
        }
      },
      "outputs": {
        "processed_data": {
          "path": "/opt/ml/processing/output"
        }
      },
      "arguments": {},
      "environment_variables": {
        "required": [
          "STRATA_COLUMN"
        ],
        "optional": {
          "SAMPLING_STRATEGY": "balanced",
          "TARGET_SAMPLE_SIZE": "1000",
          "MIN_SAMPLES_PER_STRATUM": "10",
          "VARIANCE_COLUMN": "",
          "RANDOM_STATE": "42"
        }
      },
      "description": "\n    Stratified sampling script that:\n    1. Reads processed data from tabular_preprocessing output structure\n    2. Applies stratified sampling with configurable allocation strategies\n    3. Maintains folder structure compatibility for seamless pipeline integration\n    4. Handles different job types (training vs non-training)\n    \n    Contract aligned with actual script implementation:\n    - Inputs: DATA (required) - reads from /opt/ml/processing/input/data\n    - Outputs: processed_data (primary) - writes to /opt/ml/processing/output\n    - Arguments: job_type (required) - defines processing mode (training/validation/testing/calibration)\n    \n    Script Implementation Details:\n    - Reads CSV files from split subdirectories (train/, val/, test/)\n    - Supports three allocation strategies:\n      * balanced: Equal samples per stratum (class imbalance)\n      * proportional_min: Proportional with minimum constraints (causal analysis)\n      * optimal: Neyman allocation for variance optimization\n    - For training job_type: samples train/val splits, copies test unchanged\n    - For non-training job_types: samples only the specified split\n    - Outputs sampled files maintaining same folder structure as input\n    - Preserves test set integrity for training workflows\n    \n    Environment Variables:\n    - STRATA_COLUMN (required): Column name to stratify by\n    - SAMPLING_STRATEGY (optional): One of 'balanced', 'proportional_min', 'optimal'\n    - TARGET_SAMPLE_SIZE (optional): Total desired sample size per split\n    - MIN_SAMPLES_PER_STRATUM (optional): Minimum samples per stratum for statistical power\n    - VARIANCE_COLUMN (optional): Column for variance calculation (needed for optimal strategy)\n    - RANDOM_STATE (optional): Random seed for reproducibility\n    \n    Integration Points:\n    - Input compatible with: tabular_preprocessing output\n    - Output compatible with: xgboost_training input, other downstream processing steps\n    - Maintains SageMaker processing path contracts\n    ",
      "framework_requirements": {
        "pandas": ">=1.3.0",
        "numpy": ">=1.21.0",
        "scikit-learn": ">=1.0.0"
      }
    }
  },
  "level2": {
    "passed": true,
    "issues": [
      {
        "severity": "INFO",
        "category": "multi_variant_validation",
        "message": "Smart Specification Selection: validated against 5 variants",
        "details": {
          "contract": "stratified_sampling_contract",
          "variants": [
            "training",
            "testing",
            "validation",
            "calibration",
            "generic"
          ],
          "total_dependencies": 1,
          "total_outputs": 1,
          "contract_inputs": 1,
          "contract_outputs": 1
        },
        "recommendation": "Multi-variant validation completed successfully"
      },
      {
        "severity": "INFO",
        "category": "step_type_resolution",
        "message": "Step type resolved via registry: StratifiedSampling_Training -> StratifiedSampling -> Processing",
        "details": {
          "contract": "stratified_sampling_contract",
          "original_spec_type": "StratifiedSampling_Training",
          "canonical_name": "StratifiedSampling",
          "resolved_sagemaker_type": "Processing",
          "registry_available": true
        },
        "recommendation": "Using Processing step property paths for validation"
      },
      {
        "severity": "INFO",
        "category": "property_path_validation",
        "message": "Valid property path in output processed_data: properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
        "details": {
          "contract": "stratified_sampling_contract",
          "logical_name": "processed_data",
          "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
          "step_type": "processing",
          "validation_source": "SageMaker Documentation v2.92.2",
          "documentation_reference": "https://sagemaker.readthedocs.io/en/v2.92.2/amazon_sagemaker_model_building_pipeline.html#data-dependency-property-reference"
        },
        "recommendation": "Property path is correctly formatted for the step type"
      },
      {
        "severity": "INFO",
        "category": "property_path_validation_summary",
        "message": "Property path validation completed for stratified_sampling_contract",
        "details": {
          "contract": "stratified_sampling_contract",
          "step_type": "processing",
          "node_type": "internal",
          "total_outputs": 1,
          "outputs_with_property_paths": 1,
          "validation_reference": "https://sagemaker.readthedocs.io/en/v2.92.2/amazon_sagemaker_model_building_pipeline.html#data-dependency-property-reference",
          "documentation_version": "v2.92.2"
        },
        "recommendation": "Validated 1/1 outputs with property paths against SageMaker documentation"
      }
    ],
    "contract": {
      "entry_point": "stratified_sampling.py",
      "inputs": {
        "processed_data": {
          "path": "/opt/ml/processing/input/data"
        }
      },
      "outputs": {
        "processed_data": {
          "path": "/opt/ml/processing/output"
        }
      },
      "arguments": {},
      "environment_variables": {
        "required": [
          "STRATA_COLUMN"
        ],
        "optional": {
          "SAMPLING_STRATEGY": "balanced",
          "TARGET_SAMPLE_SIZE": "1000",
          "MIN_SAMPLES_PER_STRATUM": "10",
          "VARIANCE_COLUMN": "",
          "RANDOM_STATE": "42"
        }
      },
      "description": "\n    Stratified sampling script that:\n    1. Reads processed data from tabular_preprocessing output structure\n    2. Applies stratified sampling with configurable allocation strategies\n    3. Maintains folder structure compatibility for seamless pipeline integration\n    4. Handles different job types (training vs non-training)\n    \n    Contract aligned with actual script implementation:\n    - Inputs: DATA (required) - reads from /opt/ml/processing/input/data\n    - Outputs: processed_data (primary) - writes to /opt/ml/processing/output\n    - Arguments: job_type (required) - defines processing mode (training/validation/testing/calibration)\n    \n    Script Implementation Details:\n    - Reads CSV files from split subdirectories (train/, val/, test/)\n    - Supports three allocation strategies:\n      * balanced: Equal samples per stratum (class imbalance)\n      * proportional_min: Proportional with minimum constraints (causal analysis)\n      * optimal: Neyman allocation for variance optimization\n    - For training job_type: samples train/val splits, copies test unchanged\n    - For non-training job_types: samples only the specified split\n    - Outputs sampled files maintaining same folder structure as input\n    - Preserves test set integrity for training workflows\n    \n    Environment Variables:\n    - STRATA_COLUMN (required): Column name to stratify by\n    - SAMPLING_STRATEGY (optional): One of 'balanced', 'proportional_min', 'optimal'\n    - TARGET_SAMPLE_SIZE (optional): Total desired sample size per split\n    - MIN_SAMPLES_PER_STRATUM (optional): Minimum samples per stratum for statistical power\n    - VARIANCE_COLUMN (optional): Column for variance calculation (needed for optimal strategy)\n    - RANDOM_STATE (optional): Random seed for reproducibility\n    \n    Integration Points:\n    - Input compatible with: tabular_preprocessing output\n    - Output compatible with: xgboost_training input, other downstream processing steps\n    - Maintains SageMaker processing path contracts\n    ",
      "framework_requirements": {
        "pandas": ">=1.3.0",
        "numpy": ">=1.21.0",
        "scikit-learn": ">=1.0.0"
      }
    },
    "specifications": {
      "stratified_sampling_spec": {
        "step_type": "StratifiedSampling_Training",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "processed_data",
            "dependency_type": "processing_output",
            "required": true,
            "compatible_sources": [
              "TabularPreprocessing",
              "ProcessingStep"
            ],
            "data_type": "S3Uri",
            "description": "Processed tabular data from preprocessing step for stratified sampling"
          }
        ],
        "outputs": [
          {
            "logical_name": "processed_data",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Stratified sampled data with balanced train/val/test splits"
          }
        ]
      },
      "stratified_sampling_calibration_spec": {
        "step_type": "StratifiedSampling_Calibration",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "processed_data",
            "dependency_type": "processing_output",
            "required": true,
            "compatible_sources": [
              "TabularPreprocessing",
              "ProcessingStep"
            ],
            "data_type": "S3Uri",
            "description": "Processed calibration data from preprocessing step for stratified sampling"
          }
        ],
        "outputs": [
          {
            "logical_name": "processed_data",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Stratified sampled calibration data"
          }
        ]
      },
      "stratified_sampling_training_spec": {
        "step_type": "StratifiedSampling_Training",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "processed_data",
            "dependency_type": "processing_output",
            "required": true,
            "compatible_sources": [
              "TabularPreprocessing",
              "ProcessingStep"
            ],
            "data_type": "S3Uri",
            "description": "Processed training data from preprocessing step for stratified sampling"
          }
        ],
        "outputs": [
          {
            "logical_name": "processed_data",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Stratified sampled training data with balanced train/val/test splits"
          }
        ]
      },
      "stratified_sampling_testing_spec": {
        "step_type": "StratifiedSampling_Testing",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "processed_data",
            "dependency_type": "processing_output",
            "required": true,
            "compatible_sources": [
              "TabularPreprocessing",
              "ProcessingStep"
            ],
            "data_type": "S3Uri",
            "description": "Processed testing data from preprocessing step for stratified sampling"
          }
        ],
        "outputs": [
          {
            "logical_name": "processed_data",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Stratified sampled testing data"
          }
        ]
      },
      "stratified_sampling_validation_spec": {
        "step_type": "StratifiedSampling_Validation",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "processed_data",
            "dependency_type": "processing_output",
            "required": true,
            "compatible_sources": [
              "TabularPreprocessing",
              "ProcessingStep"
            ],
            "data_type": "S3Uri",
            "description": "Processed validation data from preprocessing step for stratified sampling"
          }
        ],
        "outputs": [
          {
            "logical_name": "processed_data",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Stratified sampled validation data"
          }
        ]
      }
    },
    "unified_specification": {
      "primary_spec": {
        "step_type": "StratifiedSampling_Training",
        "node_type": "internal",
        "dependencies": [
          {
            "logical_name": "processed_data",
            "dependency_type": "processing_output",
            "required": true,
            "compatible_sources": [
              "TabularPreprocessing",
              "ProcessingStep"
            ],
            "data_type": "S3Uri",
            "description": "Processed training data from preprocessing step for stratified sampling"
          }
        ],
        "outputs": [
          {
            "logical_name": "processed_data",
            "output_type": "processing_output",
            "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
            "data_type": "S3Uri",
            "description": "Stratified sampled training data with balanced train/val/test splits"
          }
        ]
      },
      "variants": {
        "training": {
          "step_type": "StratifiedSampling_Training",
          "node_type": "internal",
          "dependencies": [
            {
              "logical_name": "processed_data",
              "dependency_type": "processing_output",
              "required": true,
              "compatible_sources": [
                "TabularPreprocessing",
                "ProcessingStep"
              ],
              "data_type": "S3Uri",
              "description": "Processed training data from preprocessing step for stratified sampling"
            }
          ],
          "outputs": [
            {
              "logical_name": "processed_data",
              "output_type": "processing_output",
              "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
              "data_type": "S3Uri",
              "description": "Stratified sampled training data with balanced train/val/test splits"
            }
          ]
        },
        "testing": {
          "step_type": "StratifiedSampling_Testing",
          "node_type": "internal",
          "dependencies": [
            {
              "logical_name": "processed_data",
              "dependency_type": "processing_output",
              "required": true,
              "compatible_sources": [
                "TabularPreprocessing",
                "ProcessingStep"
              ],
              "data_type": "S3Uri",
              "description": "Processed testing data from preprocessing step for stratified sampling"
            }
          ],
          "outputs": [
            {
              "logical_name": "processed_data",
              "output_type": "processing_output",
              "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
              "data_type": "S3Uri",
              "description": "Stratified sampled testing data"
            }
          ]
        },
        "validation": {
          "step_type": "StratifiedSampling_Validation",
          "node_type": "internal",
          "dependencies": [
            {
              "logical_name": "processed_data",
              "dependency_type": "processing_output",
              "required": true,
              "compatible_sources": [
                "TabularPreprocessing",
                "ProcessingStep"
              ],
              "data_type": "S3Uri",
              "description": "Processed validation data from preprocessing step for stratified sampling"
            }
          ],
          "outputs": [
            {
              "logical_name": "processed_data",
              "output_type": "processing_output",
              "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
              "data_type": "S3Uri",
              "description": "Stratified sampled validation data"
            }
          ]
        },
        "calibration": {
          "step_type": "StratifiedSampling_Calibration",
          "node_type": "internal",
          "dependencies": [
            {
              "logical_name": "processed_data",
              "dependency_type": "processing_output",
              "required": true,
              "compatible_sources": [
                "TabularPreprocessing",
                "ProcessingStep"
              ],
              "data_type": "S3Uri",
              "description": "Processed calibration data from preprocessing step for stratified sampling"
            }
          ],
          "outputs": [
            {
              "logical_name": "processed_data",
              "output_type": "processing_output",
              "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
              "data_type": "S3Uri",
              "description": "Stratified sampled calibration data"
            }
          ]
        },
        "generic": {
          "step_type": "StratifiedSampling_Training",
          "node_type": "internal",
          "dependencies": [
            {
              "logical_name": "processed_data",
              "dependency_type": "processing_output",
              "required": true,
              "compatible_sources": [
                "TabularPreprocessing",
                "ProcessingStep"
              ],
              "data_type": "S3Uri",
              "description": "Processed tabular data from preprocessing step for stratified sampling"
            }
          ],
          "outputs": [
            {
              "logical_name": "processed_data",
              "output_type": "processing_output",
              "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
              "data_type": "S3Uri",
              "description": "Stratified sampled data with balanced train/val/test splits"
            }
          ]
        }
      },
      "unified_dependencies": {
        "processed_data": {
          "logical_name": "processed_data",
          "dependency_type": "processing_output",
          "required": true,
          "compatible_sources": [
            "TabularPreprocessing",
            "ProcessingStep"
          ],
          "data_type": "S3Uri",
          "description": "Processed tabular data from preprocessing step for stratified sampling"
        }
      },
      "unified_outputs": {
        "processed_data": {
          "logical_name": "processed_data",
          "output_type": "processing_output",
          "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
          "data_type": "S3Uri",
          "description": "Stratified sampled data with balanced train/val/test splits"
        }
      },
      "dependency_sources": {
        "processed_data": [
          "training",
          "testing",
          "validation",
          "calibration",
          "generic"
        ]
      },
      "output_sources": {
        "processed_data": [
          "training",
          "testing",
          "validation",
          "calibration",
          "generic"
        ]
      },
      "variant_count": 5
    }
  },
  "level3": {
    "passed": true,
    "issues": [],
    "specification": {
      "step_type": "StratifiedSampling_Training",
      "node_type": "internal",
      "dependencies": [
        {
          "logical_name": "processed_data",
          "dependency_type": "processing_output",
          "required": true,
          "compatible_sources": [
            "TabularPreprocessing",
            "ProcessingStep"
          ],
          "data_type": "S3Uri",
          "description": "Processed tabular data from preprocessing step for stratified sampling"
        }
      ],
      "outputs": [
        {
          "logical_name": "processed_data",
          "output_type": "processing_output",
          "property_path": "properties.ProcessingOutputConfig.Outputs['processed_data'].S3Output.S3Uri",
          "data_type": "S3Uri",
          "description": "Stratified sampled data with balanced train/val/test splits"
        }
      ]
    }
  },
  "level4": {
    "passed": true,
    "issues": [
      {
        "severity": "WARNING",
        "category": "configuration_fields",
        "message": "Required configuration field not accessed in builder: project_root_folder",
        "details": {
          "field_name": "project_root_folder",
          "builder": "stratified_sampling"
        },
        "recommendation": "Access required field project_root_folder in builder or make it optional"
      },
      {
        "severity": "INFO",
        "category": "required_field_validation",
        "message": "Builder has required fields but no explicit validation logic detected",
        "details": {
          "required_fields": [
            "author",
            "strata_column",
            "region",
            "role",
            "service_name",
            "bucket",
            "project_root_folder",
            "pipeline_version"
          ],
          "builder": "stratified_sampling"
        },
        "recommendation": "Consider adding explicit validation logic for required configuration fields"
      }
    ],
    "builder_analysis": {
      "config_accesses": [
        {
          "field_name": "job_type",
          "line_number": 72,
          "context": "line_72"
        },
        {
          "field_name": "job_type",
          "line_number": 145,
          "context": "line_145"
        },
        {
          "field_name": "job_type",
          "line_number": 151,
          "context": "line_151"
        },
        {
          "field_name": "strata_column",
          "line_number": 154,
          "context": "line_154"
        },
        {
          "field_name": "strata_column",
          "line_number": 154,
          "context": "line_154"
        },
        {
          "field_name": "sampling_strategy",
          "line_number": 158,
          "context": "line_158"
        },
        {
          "field_name": "sampling_strategy",
          "line_number": 163,
          "context": "line_163"
        },
        {
          "field_name": "target_sample_size",
          "line_number": 166,
          "context": "line_166"
        },
        {
          "field_name": "min_samples_per_stratum",
          "line_number": 170,
          "context": "line_170"
        },
        {
          "field_name": "sampling_strategy",
          "line_number": 175,
          "context": "line_175"
        },
        {
          "field_name": "variance_column",
          "line_number": 176,
          "context": "line_176"
        },
        {
          "field_name": "use_large_processing_instance",
          "line_number": 192,
          "context": "line_192"
        },
        {
          "field_name": "processing_instance_type_large",
          "line_number": 191,
          "context": "line_191"
        },
        {
          "field_name": "processing_instance_type_small",
          "line_number": 193,
          "context": "line_193"
        },
        {
          "field_name": "processing_framework_version",
          "line_number": 197,
          "context": "line_197"
        },
        {
          "field_name": "processing_instance_count",
          "line_number": 200,
          "context": "line_200"
        },
        {
          "field_name": "processing_volume_size",
          "line_number": 201,
          "context": "line_201"
        },
        {
          "field_name": "strata_column",
          "line_number": 218,
          "context": "line_218"
        },
        {
          "field_name": "sampling_strategy",
          "line_number": 221,
          "context": "line_221"
        },
        {
          "field_name": "target_sample_size",
          "line_number": 222,
          "context": "line_222"
        },
        {
          "field_name": "min_samples_per_stratum",
          "line_number": 223,
          "context": "line_223"
        },
        {
          "field_name": "random_state",
          "line_number": 224,
          "context": "line_224"
        },
        {
          "field_name": "variance_column",
          "line_number": 227,
          "context": "line_227"
        },
        {
          "field_name": "variance_column",
          "line_number": 228,
          "context": "line_228"
        },
        {
          "field_name": "job_type",
          "line_number": 329,
          "context": "line_329"
        },
        {
          "field_name": "job_type",
          "line_number": 359,
          "context": "line_359"
        }
      ],
      "validation_calls": [],
      "default_assignments": [],
      "class_definitions": [
        {
          "class_name": "StratifiedSamplingStepBuilder",
          "line_number": 38,
          "base_classes": [
            "StepBuilderBase"
          ],
          "decorators": []
        }
      ],
      "method_definitions": [
        {
          "method_name": "__init__",
          "line_number": 46,
          "args": [
            "self",
            "config",
            "sagemaker_session",
            "role",
            "registry_manager",
            "dependency_resolver"
          ],
          "decorators": [],
          "is_async": false
        },
        {
          "method_name": "validate_configuration",
          "line_number": 117,
          "args": [
            "self"
          ],
          "decorators": [],
          "is_async": false
        },
        {
          "method_name": "_create_processor",
          "line_number": 183,
          "args": [
            "self"
          ],
          "decorators": [],
          "is_async": false
        },
        {
          "method_name": "_get_environment_variables",
          "line_number": 207,
          "args": [
            "self"
          ],
          "decorators": [],
          "is_async": false
        },
        {
          "method_name": "_get_inputs",
          "line_number": 232,
          "args": [
            "self",
            "inputs"
          ],
          "decorators": [],
          "is_async": false
        },
        {
          "method_name": "_get_outputs",
          "line_number": 285,
          "args": [
            "self",
            "outputs"
          ],
          "decorators": [],
          "is_async": false
        },
        {
          "method_name": "_get_job_arguments",
          "line_number": 346,
          "args": [
            "self"
          ],
          "decorators": [],
          "is_async": false
        },
        {
          "method_name": "create_step",
          "line_number": 366,
          "args": [
            "self"
          ],
          "decorators": [],
          "is_async": false
        }
      ],
      "import_statements": [
        {
          "type": "from_import",
          "module": "typing",
          "name": "Dict",
          "alias": null,
          "line_number": 1
        },
        {
          "type": "from_import",
          "module": "typing",
          "name": "Optional",
          "alias": null,
          "line_number": 1
        },
        {
          "type": "from_import",
          "module": "typing",
          "name": "Any",
          "alias": null,
          "line_number": 1
        },
        {
          "type": "from_import",
          "module": "typing",
          "name": "List",
          "alias": null,
          "line_number": 1
        },
        {
          "type": "from_import",
          "module": "pathlib",
          "name": "Path",
          "alias": null,
          "line_number": 2
        },
        {
          "type": "import",
          "module": "logging",
          "alias": null,
          "line_number": 3
        },
        {
          "type": "import",
          "module": "importlib",
          "alias": null,
          "line_number": 4
        },
        {
          "type": "from_import",
          "module": "sagemaker.workflow.steps",
          "name": "ProcessingStep",
          "alias": null,
          "line_number": 6
        },
        {
          "type": "from_import",
          "module": "sagemaker.workflow.steps",
          "name": "Step",
          "alias": null,
          "line_number": 6
        },
        {
          "type": "from_import",
          "module": "sagemaker.processing",
          "name": "ProcessingInput",
          "alias": null,
          "line_number": 7
        },
        {
          "type": "from_import",
          "module": "sagemaker.processing",
          "name": "ProcessingOutput",
          "alias": null,
          "line_number": 7
        },
        {
          "type": "from_import",
          "module": "sagemaker.sklearn",
          "name": "SKLearnProcessor",
          "alias": null,
          "line_number": 8
        },
        {
          "type": "from_import",
          "module": "configs.config_stratified_sampling_step",
          "name": "StratifiedSamplingConfig",
          "alias": null,
          "line_number": 10
        },
        {
          "type": "from_import",
          "module": "core.base.builder_base",
          "name": "StepBuilderBase",
          "alias": null,
          "line_number": 11
        },
        {
          "type": "from_import",
          "module": "specs.stratified_sampling_training_spec",
          "name": "STRATIFIED_SAMPLING_TRAINING_SPEC",
          "alias": null,
          "line_number": 15
        },
        {
          "type": "from_import",
          "module": "specs.stratified_sampling_calibration_spec",
          "name": "STRATIFIED_SAMPLING_CALIBRATION_SPEC",
          "alias": null,
          "line_number": 18
        },
        {
          "type": "from_import",
          "module": "specs.stratified_sampling_validation_spec",
          "name": "STRATIFIED_SAMPLING_VALIDATION_SPEC",
          "alias": null,
          "line_number": 21
        },
        {
          "type": "from_import",
          "module": "specs.stratified_sampling_testing_spec",
          "name": "STRATIFIED_SAMPLING_TESTING_SPEC",
          "alias": null,
          "line_number": 24
        },
        {
          "type": "from_import",
          "module": "sagemaker.workflow.functions",
          "name": "Join",
          "alias": null,
          "line_number": 327
        }
      ],
      "config_class_usage": []
    },
    "config_analysis": {
      "class_name": "StratifiedSamplingConfig",
      "fields": {
        "author": {
          "type": "<class 'str'>",
          "required": true
        },
        "bucket": {
          "type": "<class 'str'>",
          "required": true
        },
        "role": {
          "type": "<class 'str'>",
          "required": true
        },
        "region": {
          "type": "<class 'str'>",
          "required": true
        },
        "service_name": {
          "type": "<class 'str'>",
          "required": true
        },
        "pipeline_version": {
          "type": "<class 'str'>",
          "required": true
        },
        "model_class": {
          "type": "<class 'str'>",
          "required": false
        },
        "current_date": {
          "type": "<class 'str'>",
          "required": false
        },
        "framework_version": {
          "type": "<class 'str'>",
          "required": false
        },
        "py_version": {
          "type": "<class 'str'>",
          "required": false
        },
        "source_dir": {
          "type": "typing.Optional[str]",
          "required": false
        },
        "project_root_folder": {
          "type": "<class 'str'>",
          "required": true
        },
        "processing_instance_count": {
          "type": "<class 'int'>",
          "required": false
        },
        "processing_volume_size": {
          "type": "<class 'int'>",
          "required": false
        },
        "processing_instance_type_large": {
          "type": "<class 'str'>",
          "required": false
        },
        "processing_instance_type_small": {
          "type": "<class 'str'>",
          "required": false
        },
        "use_large_processing_instance": {
          "type": "<class 'bool'>",
          "required": false
        },
        "processing_source_dir": {
          "type": "typing.Optional[str]",
          "required": false
        },
        "processing_entry_point": {
          "type": "<class 'str'>",
          "required": false
        },
        "processing_script_arguments": {
          "type": "typing.Optional[typing.List[str]]",
          "required": false
        },
        "processing_framework_version": {
          "type": "<class 'str'>",
          "required": false
        },
        "strata_column": {
          "type": "<class 'str'>",
          "required": true
        },
        "job_type": {
          "type": "<class 'str'>",
          "required": false
        },
        "sampling_strategy": {
          "type": "<class 'str'>",
          "required": false
        },
        "target_sample_size": {
          "type": "<class 'int'>",
          "required": false
        },
        "min_samples_per_stratum": {
          "type": "<class 'int'>",
          "required": false
        },
        "variance_column": {
          "type": "typing.Optional[str]",
          "required": false
        },
        "random_state": {
          "type": "<class 'int'>",
          "required": false
        },
        "aws_region": {
          "type": "property",
          "required": false
        },
        "effective_instance_type": {
          "type": "property",
          "required": false
        },
        "effective_source_dir": {
          "type": "property",
          "required": false
        },
        "full_script_path": {
          "type": "property",
          "required": false
        },
        "model_extra": {
          "type": "property",
          "required": false
        },
        "model_fields_set": {
          "type": "property",
          "required": false
        },
        "pipeline_description": {
          "type": "property",
          "required": false
        },
        "pipeline_name": {
          "type": "property",
          "required": false
        },
        "pipeline_s3_loc": {
          "type": "property",
          "required": false
        },
        "resolved_processing_source_dir": {
          "type": "property",
          "required": false
        },
        "resolved_source_dir": {
          "type": "property",
          "required": false
        },
        "script_contract": {
          "type": "property",
          "required": false
        },
        "script_path": {
          "type": "property",
          "required": false
        },
        "step_catalog": {
          "type": "property",
          "required": false
        }
      },
      "required_fields": [
        "author",
        "bucket",
        "role",
        "region",
        "service_name",
        "pipeline_version",
        "project_root_folder",
        "strata_column"
      ],
      "optional_fields": [
        "model_class",
        "current_date",
        "framework_version",
        "py_version",
        "source_dir",
        "processing_instance_count",
        "processing_volume_size",
        "processing_instance_type_large",
        "processing_instance_type_small",
        "use_large_processing_instance",
        "processing_source_dir",
        "processing_entry_point",
        "processing_script_arguments",
        "processing_framework_version",
        "job_type",
        "sampling_strategy",
        "target_sample_size",
        "min_samples_per_stratum",
        "variance_column",
        "random_state",
        "aws_region",
        "effective_instance_type",
        "effective_source_dir",
        "full_script_path",
        "model_extra",
        "model_fields_set",
        "pipeline_description",
        "pipeline_name",
        "pipeline_s3_loc",
        "resolved_processing_source_dir",
        "resolved_source_dir",
        "script_contract",
        "script_path",
        "step_catalog"
      ],
      "default_values": {
        "author": "PydanticUndefined",
        "bucket": "PydanticUndefined",
        "role": "PydanticUndefined",
        "region": "PydanticUndefined",
        "service_name": "PydanticUndefined",
        "pipeline_version": "PydanticUndefined",
        "model_class": "xgboost",
        "current_date": "PydanticUndefined",
        "framework_version": "2.1.0",
        "py_version": "py310",
        "source_dir": null,
        "project_root_folder": "PydanticUndefined",
        "processing_instance_count": 1,
        "processing_volume_size": 500,
        "processing_instance_type_large": "ml.m5.4xlarge",
        "processing_instance_type_small": "ml.m5.2xlarge",
        "use_large_processing_instance": false,
        "processing_source_dir": null,
        "processing_entry_point": "stratified_sampling.py",
        "processing_script_arguments": null,
        "processing_framework_version": "1.2-1",
        "strata_column": "PydanticUndefined",
        "job_type": "training",
        "sampling_strategy": "balanced",
        "target_sample_size": 1000,
        "min_samples_per_stratum": 10,
        "variance_column": null,
        "random_state": 42
      }
    }
  },
  "overall_status": "PASSING",
  "scoring": {
    "overall_score": 100.0,
    "quality_rating": "Excellent",
    "level_scores": {
      "level1_script_contract": 100.0,
      "level2_contract_spec": 100.0,
      "level3_spec_dependencies": 100.0,
      "level4_builder_config": 100.0
    }
  },
  "metadata": {
    "script_name": "stratified_sampling",
    "validation_timestamp": "2025-09-28T10:07:57.949315",
    "validator_version": "1.0.0",
    "script_path": "/Users/tianpeixie/github_workspace/cursus/src/cursus/steps/scripts/stratified_sampling.py"
  }
}